## 렌더링이란

- 웹 브라우저는 HTML문서를 해석하고, 화면을 통해 해석한 결과를 보여줍니다.

- HTML, CSS, JavaScript 등의 리소스를 서버로부터 다운받고, 브라우저에서 그래픽 형태로 출력해주는 과정을 **렌더링**이라고 부릅니다.

- 웹 브라우저가 원본 HTML, CSS, JavaScript 문서를 읽어들인 후, 스타일을 입히고 대화형 페이지로 만들어 view port에 표시하기까지의 과정을 **Critical Rendering Path**라고 부릅니다.

---

## 과정

1. 브라우저는 서버로부터 HTML, CSS 등 웹 사이트에 필요한 리소스를 다운받습니다.

     - 이 때, 렌더링 엔진은 서버로부터 받은 데이터를 웹 표준화기구인 W3C 명세에 따라 해석하는데, 이 해석과정을 **파싱**이라고 부릅니다.

2. 렌더링 엔진은 HTML문서를 파싱하여, **DOM 트리**를 만듭니다.

3. 렌더링 엔진이 HTML문서를 파싱하다가 스타일 태그를 만나거나, 외부 css 파일을 포함하는 스타일 요소를 만나게 되면 HTML 파싱 작업을 중지하고, CSS 파싱 작업을 시작하여, **CSSOM 트리**를 만듭니다.

4.  DOM 트리와 CSSOM 트리를 결합해 **렌더 트리**를 형성합니다.

    - 렌더 트리를 생성하는 과정까지를 **Construction**이라고 합니다.

    - 이 때, 화면에 드러나지 않는 할당요소는 렌더 트리에 포함되지 않습니다. 렌더 트리에는 페이지를 렌더링 하는데 필요한 노드만 포함됩니다.

5. HTML 파싱 중, 자바스크립트를 의미하는 ``` <script> ``` 태그를 만나게 되면, DOM 파싱을 중지하고 자바스크립트 엔진에게 제어권한을 넘깁니다. 그리고 스크립트를 모두 실행하면, 다시 DOM을 그리기 시작합니다.

    - 브라우저의 자바스크립트 엔진은 서버에서 응답한 자바스크립트를 파싱하여, **AST(추상 구문 트리)**를 생성하고, **바이트 코드**로 변환하여 실행합니다.

        - 서버로부터 응답된 자바스크립트 코드는 각각의 의미를 갖는 토큰으로 분해되며, 이 토큰이 결합되어 AST를 형성합니다.

            - AST: 프로그램 내에서 발생하는 기능을 나타내기 위해 만들어진 **구조화된 트리**

        - **인터프리터**는 생성된 AST를 가상머신이 이해할 수 있는 바이트코드로 변환합니다.

    - 이 때, 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있으며, 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합됩니다.


    - HTML 파싱은 위에서 아래로 동기적으로 이루어지기 때문에, HTML 파싱은 ```<script>```의 위치에 따라 지연될 수 있습니다.

        ```
        자바스크립트 코드가 DOM, CSSOM을 변경하여 HTML노드를 생성하는 경우, HTML 파싱이 완료되어 있어야 하기 때문에, <script>는 되도록 <body>가 끝나는 부분에 위치하는 편이 좋을 수 있습니다. 하지만, <script>가 <body> 맨 아래에 위치할 때, 사용자가 자바스크립트 코드 파싱 중에 웹 상호작용을 시도한다면 비정상적으로 작동할 수 있습니다.

        그렇기 때문에 브라우저는 스크립트 파일을 병렬로 불러오는 방식으로 DOM 렌더 과정을 막지 않게 선언할 수 있습니다. 이를 가능하게 하는 키워드가 async, defer입니다.
        
        1. async 스크립트는 <script>를 만나고, DOM 렌더 과정을 방해하지 않도록 스크립트 파일의 로딩을 병렬로 처리합니다. 하지만, 파일의 로딩을 마치게 되면 그 즉시 DOM 렌더를 멈추고 async 방식으로 불러온 스크립트 파일의 해석을 시작하기 때문에, 실행 순서가 보장되지 않습니다. 불러온 스크립트 파일의 해석이 언제 끝날지 모르기 때문입니다.

        2. defer 스크립트도 <script>를 만나고, DOM 렌더 과정을 방해하지 않도록 스크립트 파일의 로딩을 병렬로 처리합니다. 하지만, defer 스크립트의 해석은 DOM의 렌더 과정이 종료된 후에 시작됩니다. 그래서, defer 스크립트는 실행 순서가 보장되기 때문에, 실제도 더 빨리 로드된 스크립트가 있다 하더라도, 실행은 항상 파일에 선언한 순서대로 이루어집니다.

        따라서, '기본적으로 DOM의 모든 엘리먼트에 접근할 수 있고, 실행 순서도 보장하는 defer 스크립트를 좀 더 범용적으로 사용할 수 있다'라고 말할 수 있습니다.
        ```

6. 렌더링 엔진은 **디바이스 view port**내에서, 렌더 트리의 노드들을 화면의 올바른 곳에 표시하기 위해 정확한 위치와 크기를 **계산**합니다.

    - 이 단계를 **레이아웃(리플로우) 단계**라고 부릅니다.

    - 이 작업이 끝나면 렌더링 엔진은 각 요소가 어디에 어떤 크기로 표현되는지 알게 되요.

7. **UI BackEnd는 Render Tree의 노드**들을 돌며, **UI를 그리는 Paint Event**를 발생시킵니다.

    - 그 다음, 노드들의 레이어를 순서대로 구성하는 **Composition 단계**를 거칩니다.
        - (z-index가 낮은 요소를 먼저 놓고, 높은 요소를 놓는 과정으로 생각하면 됩니다)

    - Layout단계부터 Composition까지의 과정을 **Operation**이라고 합니다.